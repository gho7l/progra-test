<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>test</title>
        <link rel="stylesheet" href="../css/style.css">
    </head>

    <body>
        <header>
            <nav>
                <ul>
                    <a href="../index.html"><li>HOME</li></a>
                    <a href="sort.html"><li>SORT</li></a>
                    <a href="save_load.html"><li>SAVE & LOAD</li></a>
                    <a href="array.html"><li>ARRAY</li></a>
                    <a href="interface.html"><li>INTERFACE</li></a>
                    <a href="exception.html"><li>EXCEPTION</li></a>
                    <a href="search.html"><li>SEARCH</li></a>
                    <a href="string.html"><li>STRING</li></a>
                    <a href="recursives.html"><li class="active">RECURSIVES</li></a>
                    <a href="linkedlist.html"><li>LINKEDLIST</li></a>
                    <a href="bst.html"><li>BST</li></a>
                    <a href="trivia.html"><li>TRIVIA</li></a>
                    <a href="exercices.html"><li>EXERCICES</li></a>
                </ul>
            </nav>
        </header>
        <main>
            <h1>RECURSIVES</h1>
            <div id="recusivite-div">
                <pre>
<!--             -->public static double power(double x, int n) {
<!--             -->    if(n == 0)
<!--             -->        return 1;
<!--             -->    else if(n > 0)
<!--             -->        return x * power(x, n-1);
<!--             -->    else 
<!--             -->        return 1/(power(x, Math.abs(n)));
<!--             -->}
                    
<!--             -->public static int gcd(int x, int y) {
<!--             -->    if(y == 0)
<!--             -->        return x;
<!--             -->    else 
<!--             -->        return gcd(y, x%y);
<!--             -->}
                    
<!--             -->public static int factorial(int n) {
<!--             -->    if(n == 0) 
<!--             -->        return 1;
<!--             -->    else
<!--             -->        return n * factorial(n-1);
<!--             -->}
                    
<!--             -->public static int fibonacci(int n) {
<!--             -->    if(n &lt;= 2) 
<!--             -->        return 1;
<!--             -->    else 
<!--             -->        return fibonacci(n-1) + fibonacci(n-2);
<!--             -->}
                    
<!--             -->public static int nar(int n) {
<!--             -->    return (fibo_i(n) - 1) * 2;
<!--             -->}
                    
<!--             -->public static double newton(int a, int n) {
<!--             -->    if(n == 0)
<!--             -->        return a;
<!--             -->    else {
<!--             -->        double newton = newton(a, n-1);
<!--             -->        return 1/2.0 * (newton + (a/newton));
<!--             -->    }
<!--             -->}
                    
<!--             -->public static double taylor_e(int x, int n) {
<!--             -->    if(n == 0) 
<!--             -->        return 1;
<!--             -->    else
<!--             -->        return power(x, n) / factorial(n) + taylor_e(x, n-1);
<!--             -->}
                    
<!--             -->public static double taylor_cos(int x, int n) {
<!--             -->    if(n &lt; 0)
<!--             -->        return 0;
<!--             -->    else
<!--             -->        return power(x, 4*n) / factorial(4*n) - power(x, 4*n+2) / factorial(4*n+2) + taylor_cos(x, n-1);
<!--             -->}
                    
<!--             -->public static double taylor_sin(int x, int n) {
<!--             -->    if(n &lt; 0)
<!--             -->        return 0;
<!--             -->    else
<!--             -->        return power(x, 4*n+1)/factorial(4*n+1) - power(x, 4*n+3)/factorial(4*n+3) + taylor_sin(x, n-1);
<!--             -->}
                    
<!--             -->public static double newton(double a, double precision) {
<!--             -->    return newton(a, a, precision);
<!--             -->}
                    
<!--             -->private static double newton(double a, double approx, double precision) {
<!--             -->    double newApprox = 1.0/2 * (approx + a/approx);
<!--             -->    if(Math.abs(newApprox - approx) < precision)
<!--             -->        return newApprox;
<!--             -->    else 
<!--             -->        return newton(a, newApprox, precision);
<!--             -->}
                    
<!--             -->public static double exp(double a, double precision) {
<!--             -->    return exp(a, 0, precision, 0);
<!--             -->}
                    
<!--             -->private static double exp(double a, double approx, double precision, int n) {
<!--             -->    double newApprox = Math.pow(a, n)/factorial(n) + approx;
<!--             -->    if(Math.abs(newapprox-approx) &lt; precision) {
<!--             -->        if(n &lt; 0)
<!--             -->            return -1;
<!--             -->        return newApprox;
<!--             -->    }
<!--             -->    else
<!--             -->        return exp(a, newApprox, precision, n+1);
<!--             -->}
                    
<!--             -->public static void hanoi(int n, int i, int j) {
<!--             -->    if(n > 0) {
<!--             -->        hanoi(n-1, i, 6-(i+j));
<!--             -->        System.out.println(i + " => " + j);
<!--             -->        hanoi(n-1, 6-(i+j), j);
<!--             -->    }
<!--             -->}
                    
<!--             -->public Point2D drawVector(Graphics2D g, Point2D p, double length, double angle) {
<!--             -->    Point2D pEnd = new Point2D.Float();
<!--             -->    double newX = p.getX() + Math.cos(Math.toRadians(angle))*length;
<!--             -->    double newY = p.getY() + Math.sin(Math.toRadians(angle))*length;
<!--             -->    pEnd.setLocation((int) newX, (int) newY);
<!--             -->    g.drawLine((int) p.getX(), (int) p.getY(), (int) newX, (int) newY);
<!--             -->    return pEnd;
<!--             -->}
                    
<!--             -->public void drawFractalTree(Graphics2D g, Point2D p, double length, double angle) {
<!--             -->    if(length > 1) {
<!--             -->        p = drawVector(g, p, length, angle);
<!--             -->        drawFractalTree(g, p, length*f1, (angle - diffAngle));
<!--             -->        drawFractalTree(g, p, length*f2, (angle + diffAngle));
<!--             -->    }
<!--             -->}
                    
<!--             -->public void SierpinskiTriangle(Graphics g, Point2D p, double width, double height, int n) {
<!--             -->    if(n > 0) {
<!--             -->        g.drawLine((int) p.getX(), (int) p.getY(), (int) (p.getX() - width/2.0), (int) (p.getY() + height));
<!--             -->        g.drawLine((int) (p.getX() - width/2.0), (int) (p.getY() + height), (int) (p.getX() + width/2.0), (int) (p.getY() + height));
<!--             -->        g.drawLine((int) (p.getX() + width/2.0), (int) (p.getY() + height),(int) (p.getX()), (int) (p.getY()));
<!--             -->        SierpinskiTriangle(g, p, width/2.0, height/2.0, n-1);
<!--             -->        SierpinskiTriangle(g, new Point2D.Double((int) (p.getX() - width/4.0), (int) (p.getY() + height/2.0), width/2.0, height/2, n-1);
<!--             -->        SierpinskiTriangle(g, new Point2D.Double((int) (p.getX() + width/4.0), (int) (p.getY() + height/2.0), width/2.0, height/2, n-1);
<!--             -->    }
<!--             -->}
                </pre>
            </div>
        </main>
    </body>
</html>